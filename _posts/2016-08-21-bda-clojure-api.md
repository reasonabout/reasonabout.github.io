---
layout: post
title:  "Full Disclojure"
comments: true
date:   2016-08-21
author: Ben Allred
featured_image: /assets/bda/2016/08/clojure-code.png
categories: ['coding']
tags: ['api', 'web sockets', 'oauth']
---
> **Q**: How can I think more like a functional programmer?<br />
> **A**: You can't change the way you think. Instead, you should write a function that accepts the way you currently think and returns a new way of thinking which is generated by merging your current way of thinking - excluding non-functional ideals - with functional programming concepts.<br />
> **Q**: <span style="font-style: normal;">`you.forget(i.asked);`</span>

## What Was I Thinking?

Recently, I <span style="text-decoration: line-through;">was forced</span> had the opportunity to work on a project with an API written in Clojure. It was exciting to learn something new, but the project didn't require many updates to the API. As we neared the finish line, it occurred to me that I hadn't really had a chance to form an opinion on functional programming, and this was probably the last time (at least working for my current company) that I was going to get paid to write in a functional language. So, I decided to build a personal project in Clojure. For lack of an idea for something new to build, I chose to rewrite an API built in Node.js because it had a number of moving parts: database interaction, 3rd-party API integration, o-auth, JWT, and web sockets.

## Kiddie Pool

If there's any language in which I can claim proficiency, it's Javascript. On top of that, Node.js has fantastic package management and robust 3rd party support. I didn't appreciate how much I had taken those libraries for granted until I decided to dive into the Clojure pool.

> **Q**: Knock, knock.<br />
> **Q**: A bit of trouble with Javascript promises.<br />
> **A**: Who's there?

## Adult Swim

For better or for worse, there isn't a one-to-one ratio between npm modules and clojars. Part of the problem seemed to be that, when I found a library that claimed to do what I needed it to, I couldn't understand the example code well enough to get it working. Most of the problem seemed to be that everything I wanted to do required a deeper understanding of the underlying technologies than was previously required of me. So, I gave up and ran away....

## Splashing Around in an Effort to Avoid Drowning While Pretending I'm Swimming

I didn't run very far before deciding to fight my better judgment and dig a little deeper. Talking to a database, encoding/decoding JSON web tokens, and integrating with my 3rd-party API were a little different than I was used to, but still pretty straight forward.

The biggest challenges were o-auth and web sockets. I found some libraries that got me part of the way there, but I had to spend a lot of time reading through the official WebSocket spec and Google's o-auth documentation. Once I decided to let go of finding a Clojure library that would play nice with Socket.io on my front-end, I discovered that setting up a vanilla web socket really isn't that complicated - at least with Clojure. And the hardest part about Google o-auth is siphoning through Google's documentation which is somehow both wonderful and garbage.

## In Clojing

Once you learn how to do something one way, it's easy to just keep doing things that way. But, there's something to be said for trail blazing through unfamiliar environments. Even though I haven't really done anything new, doing familiar things in a new language makes me feel more empowered to solve the new and harder problems that lay ahead. Blah blah rhetoric. Blah blah inspiring words.

> **Q**: How many developers does it take to screw in a light bulb?<br />
> **A**: None. Thats a hardware problem.

By [Ben Allred](https://www.github.com/skuttleman)
